{"meta":{"title":"PhilJ","subtitle":"","description":"","author":"PhilJ","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"111","slug":"111","date":"2020-03-06T18:23:27.000Z","updated":"2020-03-06T18:23:27.455Z","comments":true,"path":"2020/03/07/111/","link":"","permalink":"http://yoursite.com/2020/03/07/111/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Dubbo 技术总结","slug":"2018-05-03-Dubbo-技术总结","date":"2018-05-03T13:32:44.000Z","updated":"2020-03-06T17:57:51.532Z","comments":true,"path":"2018/05/03/2018-05-03-Dubbo-技术总结/","link":"","permalink":"http://yoursite.com/2018/05/03/2018-05-03-Dubbo-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/","excerpt":"","text":"分布式RPC框架Apache Dubbo1. 软件架构的演进过程软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。 1.1 单体架构 架构说明： ​ 全部功能集中在一个项目内（All in one）。 架构优点： ​ 架构简单，前期开发成本低、开发周期短，适合小型项目。 架构缺点： ​ 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。 ​ 技术栈受限，只能使用一种语言开发。 ​ 系统性能扩展只能通过扩展集群节点，成本高。 1.2 垂直架构 架构说明： ​ 按照业务进行切割，形成小的单体项目。 架构优点： ​ 技术栈可扩展（不同的系统可以用不同的编程语言编写）。 架构缺点： ​ 功能集中在一个项目中，不利于开发、扩展、维护。 ​ 系统扩张只能通过集群的方式。 ​ 项目之间功能冗余、数据冗余、耦合性强。 1.3 SOA架构SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。 站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。 架构说明： ​ 将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。 架构优点： ​ 重复功能或模块抽取为服务，提高开发效率。 ​ 可重用性高。 ​ 可维护性高。 架构缺点： ​ 各系统之间业务不同，很难确认功能或模块是重复的。 ​ 抽取服务的粒度大。 ​ 系统和服务之间耦合度高。 1.4 微服务架构 架构说明： ​ 将系统服务层完全独立出来，抽取为一个一个的微服务。 ​ 抽取的粒度更细，遵循单一原则。 ​ 采用轻量级框架协议传输。 架构优点： ​ 服务拆分粒度更细，有利于提高开发效率。 ​ 可以针对不同服务制定对应的优化方案。 ​ 适用于互联网时代，产品迭代周期更短。 架构缺点： ​ 粒度太细导致服务太多，维护成本高。 ​ 分布式系统开发的技术成本高，对团队的挑战大。 2. Apache Dubbo概述2.1 Dubbo简介Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。 什么是RPC？ RPC全称为remote procedure call，即远程过程调用。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。 需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。 Dubbo官网地址：http://dubbo.apache.org Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 2.2 Dubbo架构Dubbo架构图（Dubbo官方提供）如下： 节点角色说明： 节点 角色名称 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 虚线都是异步访问，实线都是同步访问蓝色虚线:在启动时完成的功能红色虚线(实线)都是程序运行过程中执行的功能 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3. 服务注册中心Zookeeper通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。 3.1 Zookeeper介绍Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。 为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)： 我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径，例如：C:\\Windows\\itcast\\hello.txt。 Zookeeper树型目录服务： 流程说明： 服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 3.2 安装Zookeeper下载地址：http://archive.apache.org/dist/zookeeper/ 本课程使用的Zookeeper版本为3.4.6，下载完成后可以获得名称为zookeeper-3.4.6.tar.gz的压缩文件。 安装步骤： 第一步：安装 jdk（略）第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统第三步：解压缩压缩包​ tar -zxvf zookeeper-3.4.6.tar.gz第四步：进入zookeeper-3.4.6目录，创建data目录​ mkdir data第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg​ cd conf​ mv zoo_sample.cfg zoo.cfg第六步：打开zoo.cfg文件, 修改data属性：dataDir=/root/zookeeper-3.4.6/data 3.3 启动、停止Zookeeper进入Zookeeper的bin目录，启动服务命令 ./zkServer.sh start 停止服务命令./zkServer.sh stop 查看服务状态：./zkServer.sh status 4. Dubbo快速入门Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。 4.1 服务提供方开发开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.12.1.GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8081&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; （2）配置web.xml文件 12345678910111213&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; （3）创建服务接口 1234package com.itheima.service;public interface HelloService &#123; public String sayHello(String name);&#125; （4）创建服务实现类 12345678910package com.itheima.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.itheima.service.HelloService;@Servicepublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return \"hello \" + name; &#125;&#125; 注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务 （5）在src/main/resources下创建applicationContext-service.xml 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name=\"dubbodemo_provider\" /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address=\"zookeeper://192.168.134.129:2181\"/&gt; &lt;!-- 注册 协议和port 端口默认是20880 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20881\"&gt;&lt;/dubbo:protocol&gt; &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务 --&gt; &lt;dubbo:annotation package=\"com.itheima.service.impl\" /&gt;&lt;/beans&gt; （6）启动服务 tomcat7:run 4.2 服务消费方开发开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可 （2）配置web.xml文件 1234567891011121314151617181920&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; （3）将服务提供者工程中的HelloService接口复制到当前工程 （4）编写Controller 12345678910111213141516171819202122package com.itheima.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.itheima.service.HelloService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping(\"/demo\")public class HelloController &#123; @Reference private HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解 （5）在src/main/resources下创建applicationContext-web.xml 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name=\"dubbodemo-consumer\" /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address=\"zookeeper://192.168.134.129:2181\"/&gt; &lt;!-- 扫描的方式暴露接口 --&gt; &lt;dubbo:annotation package=\"com.itheima.controller\" /&gt;&lt;/beans&gt; （6）运行测试 tomcat7:run启动 在浏览器输入http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果 思考一：上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？ 答：这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。 思考二：在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ 答：Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。 思考三：上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？ 答：Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。 5. Dubbo管理控制台我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 5.1 安装安装步骤： （1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下 （2）启动tomcat，此war文件会自动解压 （3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号 ​ dubbo.registry.address=zookeeper://192.168.134.129:2181​ dubbo.admin.root.password=root​ dubbo.admin.guest.password=guest （4）重启tomcat 5.2 使用操作步骤： （1）访问http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root) （2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息 6. Dubbo相关配置说明6.1 包扫描1&lt;dubbo:annotation package=\"com.itheima.service\" /&gt; 服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。 如果不使用包扫描，也可以通过如下配置的方式来发布服务： 12&lt;bean id=\"helloService\" class=\"com.itheima.service.impl.HelloServiceImpl\" /&gt;&lt;dubbo:service interface=\"com.itheima.api.HelloService\" ref=\"helloService\" /&gt; 作为服务消费者，可以通过如下配置来引用服务： 12&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;&lt;dubbo:reference id=\"helloService\" interface=\"com.itheima.api.HelloService\" /&gt; 上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。 6.2 协议1&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; 一般在服务提供者一方配置，可以指定使用的协议名称和端口号。 其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。 推荐使用的是dubbo协议。 dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。 也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如： 1234567&lt;!-- 多协议配置 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\" /&gt;&lt;dubbo:protocol name=\"rmi\" port=\"1099\" /&gt;&lt;!-- 使用dubbo协议暴露服务 --&gt;&lt;dubbo:service interface=\"com.itheima.api.HelloService\" ref=\"helloService\" protocol=\"dubbo\" /&gt;&lt;!-- 使用rmi协议暴露服务 --&gt;&lt;dubbo:service interface=\"com.itheima.api.DemoService\" ref=\"demoService\" protocol=\"rmi\" /&gt; 6.3 启动时检查1&lt;dubbo:consumer check=\"false\"/&gt; 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。 建议在开发阶段将check值设置为false，在生产环境下改为true。 6.4 负载均衡负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。 在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。 配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 12345678910111213141516@Controller@RequestMapping(\"/demo\")public class HelloController &#123; //在服务消费者一方配置负载均衡策略 @Reference(check = false,loadbalance = \"random\") private HelloService helloService; @RequestMapping(\"/hello\") @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 1234567//在服务提供者一方配置负载均衡@Service(loadbalance = \"random\")public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return \"hello \" + name; &#125;&#125; 可以通过启动多个服务提供者来观察Dubbo负载均衡效果。 注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。 在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。 7. 解决Dubbo无法发布被事务代理的Service问题前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。 但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。 7.1 问题展示在入门案例的服务提供者dubbodemo_provider工程基础上进行展示 操作步骤： （1）在pom.xml文件中增加maven坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; （2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置 1234567891011121314&lt;!--数据源--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 上面连接的数据库可以自行创建 （3）在HelloServiceImpl类上加入@Transactional注解 （4）启动服务提供者和服务消费者，并访问 上面的错误为没有可用的服务提供者 查看dubbo管理控制台发现服务并没有发布，如下： 可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理 7.2 解决方案通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.itheima.service），所以后面真正发布服务的代码没有执行。 解决方式操作步骤： （1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象 12&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\"/&gt; （2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型 1234567@Service(interfaceClass = HelloService.class)@Transactionalpublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return \"hello \" + name; &#125;&#125; 此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：","categories":[],"tags":[{"name":"Apache Dubbo","slug":"Apache-Dubbo","permalink":"http://yoursite.com/tags/Apache-Dubbo/"}]},{"title":"Mybatis 技术总结3：多表查询","slug":"2018-04-21-Mybatis-技术总结3：多表查询","date":"2018-04-21T15:52:11.000Z","updated":"2020-03-06T17:23:28.934Z","comments":true,"path":"2018/04/21/2018-04-21-Mybatis-技术总结3：多表查询/","link":"","permalink":"http://yoursite.com/2018/04/21/2018-04-21-Mybatis-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"1.Mybatis多表查询1.1 一对一查询1.1.1 一对一查询的模型MapperScannerConfigurer用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 1.1.2一对一查询的语句对应的sql语句：select * from orders o,user u where o.uid=u.id; 查询的结果如下： 1.1.3 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 1.1.4 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 1.1.5 配置OrderMapper.xml1234567891011&lt;mapper namespace=\"com.itheima.mapper.OrderMapper\"&gt; &lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt; &lt;result column=\"uid\" property=\"user.id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"user.username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"user.password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"user.birthday\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"orderMap\"&gt; select * from orders o,user u where o.uid=u.id &lt;/select&gt;&lt;/mapper&gt; 其中还可以配置如下： 1234567891011&lt;resultMap id=\"orderMap\" type=\"com.itheima.domain.Order\"&gt; &lt;result property=\"id\" column=\"id\"&gt;&lt;/result&gt; &lt;result property=\"ordertime\" column=\"ordertime\"&gt;&lt;/result&gt; &lt;result property=\"total\" column=\"total\"&gt;&lt;/result&gt; &lt;association property=\"user\" javaType=\"com.itheima.domain.User\"&gt; &lt;result column=\"uid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;/association&gt;&lt;/resultMap&gt; 1.1.6 测试结果12345OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);List&lt;Order&gt; all = mapper.findAll();for(Order order : all)&#123; System.out.println(order);&#125; 1.2 一对多查询1.2.1 一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 1.2.2 一对多查询的语句对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid; 查询的结果如下： 1.2.3 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 1.2.4 创建UserMapper接口123public interface UserMapper &#123; List&lt;User&gt; findAll();&#125; 1.2.5 配置UserMapper.xml12345678910111213141516&lt;mapper namespace=\"com.itheima.mapper.UserMapper\"&gt; &lt;resultMap id=\"userMap\" type=\"com.itheima.domain.User\"&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"orderList\" ofType=\"com.itheima.domain.Order\"&gt; &lt;result column=\"oid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"ordertime\" property=\"ordertime\"&gt;&lt;/result&gt; &lt;result column=\"total\" property=\"total\"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"findAll\" resultMap=\"userMap\"&gt; select *,o.id oid from user u left join orders o on u.id=o.uid &lt;/select&gt;&lt;/mapper&gt; 1.2.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAll();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"----------------------------------\");&#125; 1.3 多对多查询1.3.1 多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 1.3.2 多对多查询的语句对应的sql语句：select u.,r.,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id; 查询的结果如下： 1.3.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125;public class Role &#123; private int id; private String rolename;&#125; 1.3.4 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 1.3.5 配置UserMapper.xml1234567891011121314&lt;resultMap id=\"userRoleMap\" type=\"com.itheima.domain.User\"&gt; &lt;result column=\"id\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"username\" property=\"username\"&gt;&lt;/result&gt; &lt;result column=\"password\" property=\"password\"&gt;&lt;/result&gt; &lt;result column=\"birthday\" property=\"birthday\"&gt;&lt;/result&gt; &lt;collection property=\"roleList\" ofType=\"com.itheima.domain.Role\"&gt; &lt;result column=\"rid\" property=\"id\"&gt;&lt;/result&gt; &lt;result column=\"rolename\" property=\"rolename\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=\"findAllUserAndRole\" resultMap=\"userRoleMap\"&gt; select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id inner join role r on ur.role_id=r.id&lt;/select&gt; 1.3.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(\"----------------------------------\");&#125; 1.4 知识小结MyBatis多表配置方式： 一对一配置：使用做配置 一对多配置：使用+做配置 多对多配置：使用+做配置 2.Mybatis的注解开发2.1 MyBatis的常用注解这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper 映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。 @Insert：实现新增 @Update：实现更新 @Delete：实现删除 @Select：实现查询 @Result：实现结果集封装 @Results：可以与@Result 一起使用，封装多个结果集 @One：实现一对一结果集封装 @Many：实现一对多结果集封装 2.2 MyBatis的增删改查我们完成简单的user表的增删改查的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445private UserMapper userMapper;@Beforepublic void before() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(true); userMapper = sqlSession.getMapper(UserMapper.class);&#125;@Testpublic void testAdd() &#123; User user = new User(); user.setUsername(\"测试数据\"); user.setPassword(\"123\"); user.setBirthday(new Date()); userMapper.add(user);&#125;@Testpublic void testUpdate() throws IOException &#123; User user = new User(); user.setId(16); user.setUsername(\"测试数据修改\"); user.setPassword(\"abc\"); user.setBirthday(new Date()); userMapper.update(user);&#125;@Testpublic void testDelete() throws IOException &#123; userMapper.delete(16);&#125;@Testpublic void testFindById() throws IOException &#123; User user = userMapper.findById(1); System.out.println(user);&#125;@Testpublic void testFindAll() throws IOException &#123; List&lt;User&gt; all = userMapper.findAll(); for(User user : all)&#123; System.out.println(user); &#125;&#125; 修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可 1234&lt;mappers&gt; &lt;!--扫描使用注解的类--&gt; &lt;mapper class=\"com.itheima.mapper.UserMapper\"&gt;&lt;/mapper&gt;&lt;/mappers&gt; 或者指定扫描包含映射关系的接口所在的包也可以 1234&lt;mappers&gt; &lt;!--扫描使用注解的类所在的包--&gt; &lt;package name=\"com.itheima.mapper\"&gt;&lt;/package&gt;&lt;/mappers&gt; 2.3 MyBatis的注解实现复杂映射开发实现复杂关系映射之前我们可以在映射文件中通过配置来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置 2.4 一对一查询2.4.1 一对一查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户 2.4.2 一对一查询的语句对应的sql语句： select * from orders; select * from user where id=查询出订单的uid;查询的结果如下： 2.4.3 创建Order和User实体123456789101112131415161718public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday;&#125; 2.4.4 创建OrderMapper接口123public interface OrderMapper &#123; List&lt;Order&gt; findAll();&#125; 2.4.5 使用注解配置Mapper123456789101112public interface OrderMapper &#123; @Select(\"select * from orders\") @Results(&#123; @Result(id=true,property = \"id\",column = \"id\"), @Result(property = \"ordertime\",column = \"ordertime\"), @Result(property = \"total\",column = \"total\"), @Result(property = \"user\",column = \"uid\", javaType = User.class, one = @One(select = \"com.itheima.mapper.UserMapper.findById\")) &#125;) List&lt;Order&gt; findAll();&#125; 123456public interface UserMapper &#123; @Select(\"select * from user where id=#&#123;id&#125;\") User findById(int id); &#125; 2.4.6 测试结果1234567@Testpublic void testSelectOrderAndUser() &#123; List&lt;Order&gt; all = orderMapper.findAll(); for(Order order : all)&#123; System.out.println(order); &#125;&#125; 2.5 一对多查询2.5.1 一对多查询的模型用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户 一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单 2.5.2 一对多查询的语句对应的sql语句： select * from user; select * from orders where uid=查询出用户的id;查询的结果如下： 2.5.3 修改User实体12345678910111213141516171819public class Order &#123; private int id; private Date ordertime; private double total; //代表当前订单从属于哪一个客户 private User user;&#125;public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList;&#125; 2.5.4 创建UserMapper接口1List&lt;User&gt; findAllUserAndOrder(); 2.5.5 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123; @Select(\"select * from user\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"orderList\",column = \"id\", javaType = List.class, many = @Many(select = \"com.itheima.mapper.OrderMapper.findByUid\")) &#125;) List&lt;User&gt; findAllUserAndOrder();&#125;public interface OrderMapper &#123; @Select(\"select * from orders where uid=#&#123;uid&#125;\") List&lt;Order&gt; findByUid(int uid);&#125; 2.5.6 测试结果123456789List&lt;User&gt; all = userMapper.findAllUserAndOrder();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Order&gt; orderList = user.getOrderList(); for(Order order : orderList)&#123; System.out.println(order); &#125; System.out.println(\"-----------------------------\");&#125; 2.6 多对多查询2.6.1 多对多查询的模型用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用 多对多查询的需求：查询用户同时查询出该用户的所有角色 2.6.2 多对多查询的语句对应的sql语句： select * from user; select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id查询的结果如下： 2.6.3 创建Role实体，修改User实体1234567891011121314151617public class User &#123; private int id; private String username; private String password; private Date birthday; //代表当前用户具备哪些订单 private List&lt;Order&gt; orderList; //代表当前用户具备哪些角色 private List&lt;Role&gt; roleList;&#125;public class Role &#123; private int id; private String rolename;&#125; 2.6.4 添加UserMapper接口方法1List&lt;User&gt; findAllUserAndRole(); 2.6.5 使用注解配置Mapper12345678910111213141516171819public interface UserMapper &#123; @Select(\"select * from user\") @Results(&#123; @Result(id = true,property = \"id\",column = \"id\"), @Result(property = \"username\",column = \"username\"), @Result(property = \"password\",column = \"password\"), @Result(property = \"birthday\",column = \"birthday\"), @Result(property = \"roleList\",column = \"id\", javaType = List.class, many = @Many(select = \"com.itheima.mapper.RoleMapper.findByUid\"))&#125;)List&lt;User&gt; findAllUserAndRole();&#125;public interface RoleMapper &#123; @Select(\"select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=#&#123;uid&#125;\") List&lt;Role&gt; findByUid(int uid);&#125; 2.6.6 测试结果12345678910UserMapper mapper = sqlSession.getMapper(UserMapper.class);List&lt;User&gt; all = mapper.findAllUserAndRole();for(User user : all)&#123; System.out.println(user.getUsername()); List&lt;Role&gt; roleList = user.getRoleList(); for(Role role : roleList)&#123; System.out.println(role); &#125; System.out.println(\"----------------------------------\");&#125;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Mybatis 技术总结2","slug":"2018-04-18-Mybatis-技术总结2","date":"2018-04-18T14:52:55.000Z","updated":"2020-03-06T19:11:32.602Z","comments":true,"path":"2018/04/18/2018-04-18-Mybatis-技术总结2/","link":"","permalink":"http://yoursite.com/2018/04/18/2018-04-18-Mybatis-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932/","excerpt":"","text":"1.Mybatis的Dao层实现1.1 传统开发方式1.1.1编写UserDao接口123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 1.1.2.编写UserDaoImpl实现123456789101112public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); sqlSession.close(); return userList; &#125;&#125; 1.1.3 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 1.2 代理开发方式1.2.1 代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 1.2.2 编写UserMapper接口 1.2.3测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 1.3 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： **UserMapper userMapper = sqlSession.getMapper(UserMapper.class);**2.MyBatis映射文件深入2.1 动态sql语句2.1.1动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 2.1.2动态 SQL 之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=\"findByCondition\" parameterType=\"user\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;if test=\"id!=0\"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"username!=null\"&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 12345678 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(\"lucy\"); User user = userMapper.findByCondition(condition); … … … 当查询条件只有id存在时，控制台打印的sql语句如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition);… … … 2.1.3 动态 SQL 之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; select * from User &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 1234567 … … … //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList);… … … foreach标签的属性含义如下： 标签用于遍历集合，它的属性： •collection：代表要遍历的集合元素，注意编写时不要写#{} •open：代表语句的开始部分 •close：代表结束部分 •item：代表遍历集合的每个元素，生成的变量名 •sperator：代表分隔符 2.2 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=\"selectUser\" select * from User&lt;/sql&gt;&lt;select id=\"findById\" parameterType=\"int\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=\"findByIds\" parameterType=\"list\" resultType=\"user\"&gt; &lt;include refid=\"selectUser\"&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=\"array\" open=\"id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 2.3 知识小结MyBatis映射文件配置： 123456789101112131415&lt;select&gt;：查询&lt;insert&gt;：插入&lt;update&gt;：修改&lt;delete&gt;：删除&lt;where&gt;：where条件&lt;if&gt;：if判断&lt;foreach&gt;：循环&lt;sql&gt;：sql片段抽取 3. MyBatis核心配置文件深入3.1typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler ②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 测试转换是否正确 1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) &#123; preparedStatement.setString(i,date.getTime()+\"\"); &#125; public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return callableStatement.getDate(i); &#125;&#125; 1234&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"com.itheima.typeHandlers.MyDateTypeHandler\"&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 测试添加操作： 12user.setBirthday(new Date());userMapper.add2(user); 数据库数据： 测试查询操作： ​ 3.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 ①导入通用PageHelper坐标1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt; &lt;!-- 指定方言 --&gt; &lt;property name=\"dialect\" value=\"mysql\"/&gt;&lt;/plugin&gt; ③测试分页代码实现12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(\"总条数：\"+pageInfo.getTotal());System.out.println(\"总页数：\"+pageInfo.getPages());System.out.println(\"当前页：\"+pageInfo.getPageNum());System.out.println(\"每页显示长度：\"+pageInfo.getPageSize());System.out.println(\"是否第一页：\"+pageInfo.isIsFirstPage());System.out.println(\"是否最后一页：\"+pageInfo.isIsLastPage()); 3.3 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件 2、typeAliases标签：设置类型别名 3、environments标签：数据源环境配置标签 4、typeHandlers标签：配置自定义类型处理器 5、plugins标签：配置MyBatis的插件 &quot;","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Mybatis 技术总结1","slug":"2018-04-16-Mybatis-技术总结1","date":"2018-04-16T13:24:11.000Z","updated":"2020-03-06T17:18:20.956Z","comments":true,"path":"2018/04/16/2018-04-16-Mybatis-技术总结1/","link":"","permalink":"http://yoursite.com/2018/04/16/2018-04-16-Mybatis-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931/","excerpt":"","text":"1.Mybatis简介1.1原始jdbc操作（查询数据） 1.2原始jdbc操作（插入数据） 1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.4 什么是Mybatismybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 2.2 环境搭建1)导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 2) 创建user数据表 3) 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get个set方法&#125; 4)编写UserMapper映射文件 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"userMapper\"&gt; &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 5) 编写MyBatis核心文件 123456789101112131415161718&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN“ \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/itheima/mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3 编写测试代码12345678910111213//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\");//打印结果System.out.println(userList);//释放资源sqlSession.close(); 2.4 知识小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 2)编写插入实体User的代码 123456789InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(\"userMapper.add\", user);System.out.println(insert);//提交事务sqlSession.commit();sqlSession.close(); 3)插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用parameterType属性指定要插入的数据类型 •Sql语句中使用#{实体属性名}方式引用实体中的属性值 •插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); •插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 4.2 MyBatis的修改数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 2)编写修改实体User的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(\"userMapper.update\", user);System.out.println(update);sqlSession.commit();sqlSession.close(); 3)修改操作注意问题 • 修改语句使用update标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作1)编写UserMapper映射文件 12345&lt;mapper namespace=\"userMapper\"&gt; &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 2)编写删除数据的代码 1234567InputStream resourceAsStream = Resources.getResourceAsStream(\"SqlMapConfig.xml\");SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(\"userMapper.delete\",3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 3)删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结1234567891011121314151617增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(\"userMapper.findAll\"); &lt;select id=\"findAll\" resultType=\"com.itheima.domain.User\"&gt; select * from User &lt;/select&gt;添加数据： sqlSession.insert(\"userMapper.add\", user); &lt;insert id=\"add\" parameterType=\"com.itheima.domain.User\"&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;修改数据： sqlSession.update(\"userMapper.update\", user); &lt;update id=\"update\" parameterType=\"com.itheima.domain.User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;删除数据：sqlSession.delete(\"userMapper.delete\",3); &lt;delete id=\"delete\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析1)environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： •UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 •POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 •JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 2)mapper标签 该标签的作用是加载映射的，加载方式有如下几种： •使用相对于类路径的资源引用，例如： •使用完全限定资源定位符（URL），例如： •使用映射器接口实现类的完全限定类名，例如： •将包内的映射器接口实现全部注册为映射器，例如： 3)Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 4)typeAliases标签 类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 5.3 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=\"jdbc.properties\"&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=\"com.itheima.domain.User\" alias=\"user\"&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=\"com/itheima/mapper/UserMapping.xml\"&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 6.MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = \"org/mybatis/builder/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： 6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback() ​","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"SpringMVC 技术总结3：文件上传、拦截器及异常处理","slug":"2018-04-06-SpringMVC-技术总结3：文件上传、拦截器及异常处理","date":"2018-04-05T17:25:12.000Z","updated":"2020-03-06T09:22:53.486Z","comments":true,"path":"2018/04/06/2018-04-06-SpringMVC-技术总结3：文件上传、拦截器及异常处理/","link":"","permalink":"http://yoursite.com/2018/04/06/2018-04-06-SpringMVC-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E3%80%81%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"SpringMVC的文件上传1-SpringMVC的请求-文件上传-客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type=“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype=“multipart/form-data” 12345&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick22\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 2-SpringMVC的请求-文件上传-文件上传的原理(理解) 3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置多媒体解析器 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"UYF-8\"/&gt; &lt;property name=\"maxUploadSize\" value=\"500000\"/&gt; &lt;/bean&gt; 后台程序 123456@RequestMapping(value=\"/quick22\") @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); &#125; 4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)完成文件上传 12345678@RequestMapping(value=\"/quick22\") @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); //获得上传文件的名称 String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(\"C:\\\\upload\\\\\"+originalFilename)); &#125; 5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick23\" method=\"post\" enctype=\"multipart/form-data\"&gt; 名称&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 文件1&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; 文件2&lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 123456789@RequestMapping(value=\"/quick23\") @ResponseBody public void save23(String username, MultipartFile[] uploadFile) throws IOException &#123; System.out.println(username); for (MultipartFile multipartFile : uploadFile) &#123; String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(\"C:\\\\upload\\\\\"+originalFilename)); &#125; &#125; 6-SpringMVC的请求-知识要点(理解，记忆) SpringMVC的拦截器01-SpringMVC拦截器-拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 03-SpringMVC拦截器-快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： 1234567891011121314public class MyInterceptor1 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(\"preHandle.....\");&#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;System.out.println(\"postHandle...\"); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(\"afterCompletion....\"); &#125;&#125; 配置：在SpringMVC的配置文件中配置 12345678&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 12345678910111213@Controllerpublic class TargetController &#123; @RequestMapping(\"/target\") public ModelAndView show()&#123; System.out.println(\"目标资源执行......\"); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"name\",\"itcast\"); modelAndView.setViewName(\"index\"); return modelAndView; &#125;&#125; 页面 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World! $&#123;name&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 04-SpringMVC拦截器-快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2， 1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(\"preHandle22222.....\"); return true; &#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; System.out.println(\"postHandle2222...\"); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(\"afterCompletion2222....\"); &#125;&#125; 配置拦截器2 12345678910111213&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor2\"/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.MyInterceptor1\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 05-SpringMVC拦截器-知识小结(记忆)拦截器中的方法说明如下 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 需求图： 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： 1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123; //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(\"user\"); if(user==null)&#123; //没有登录 response.sendRedirect(request.getContextPath()+\"/login.jsp\"); return false; &#125; //放行 访问目标资源 return true; &#125;&#125; 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： 12345678&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 12345678910@RequestMapping(\"/login\") public String login(String username,String password,HttpSession session)&#123; User user = userService.login(username,password); if(user!=null)&#123; //登录成功 将user存储到session session.setAttribute(\"user\",user); return \"redirect:/index.jsp\"; &#125; return \"redirect:/login.jsp\"; &#125; service层代码如下： 12345//service层public User login(String username, String password) &#123; User user = userDao.findByUsernameAndPassword(username,password); return user;&#125; dao层代码如下： 12345//dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException&#123; User user = jdbcTemplate.queryForObject(\"select * from sys_user where username=? and password=?\", new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; &#125; 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 12345678910&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=\"/user/login\"/&gt; &lt;bean class=\"com.itheima.interceptor.PrivilegeInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 12345678public User login(String username, String password) &#123; try &#123; User user = userDao.findByUsernameAndPassword(username,password); return user; &#125;catch (EmptyResultDataAccessException e)&#123; return null; &#125; &#125; 1. SpringMVC异常处理机制1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 123456789&lt;!--配置简单映射异常处理器--&gt; &lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=\"com.itheima.exception.MyException\" value=\"error\"/&gt; &lt;entry key=\"java.lang.ClassCastException\" value=\"error\"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver 1234567891011public class MyExceptionResolver implements HandlerExceptionResolver &#123;@Overridepublic ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(\"exceptionPage\"); return modelAndView; &#125;&#125; ②配置异常处理器 12&lt;bean id=\"exceptionResolver\" class=\"com.itheima.exception.MyExceptionResolver\"/&gt; ③编写异常页面 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456@RequestMapping(\"/quick22\")@ResponseBodypublic void quickMethod22() throws IOException, ParseException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); simpleDateFormat.parse(\"abcde\");&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器自定义异常处理步骤 ①创建异常处理器类实现HandlerExceptionResolver ②配置异常处理器 ③编写异常页面 ④测试异常跳转","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"SpringMVC 技术总结2：请求&响应","slug":"2018-04-05-SpringMVC-技术总结2：请求&响应","date":"2018-04-04T16:24:12.000Z","updated":"2020-03-06T09:19:38.039Z","comments":true,"path":"2018/04/05/2018-04-05-SpringMVC-技术总结2：请求&响应/","link":"","permalink":"http://yoursite.com/2018/04/05/2018-04-05-SpringMVC-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932%EF%BC%9A%E8%AF%B7%E6%B1%82&%E5%93%8D%E5%BA%94/","excerpt":"","text":"SpringMVC的请求和响应SpringMVC的数据响应01-SpringMVC的数据响应-数据响应方式(理解)1) 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 返回对象或集合 02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用） 03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 1234567891011121314@RequestMapping(value=\"/quick2\") public ModelAndView save2()&#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(\"username\",\"itcast\"); //设置视图名称 modelAndView.setViewName(\"success\"); return modelAndView; &#125; 04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 1234567891011 @RequestMapping(value=\"/quick3\") public ModelAndView save3(ModelAndView modelAndView)&#123; modelAndView.addObject(\"username\",\"itheima\"); modelAndView.setViewName(\"success\"); return modelAndView; &#125;@RequestMapping(value=\"/quick4\") public String save4(Model model)&#123; model.addAttribute(\"username\",\"博学谷\"); return \"success\"; &#125; 05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 12345@RequestMapping(value=\"/quick5\") public String save5(HttpServletRequest request)&#123; request.setAttribute(\"username\",\"酷丁鱼\"); return \"success\"; &#125; 06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 12345678910@RequestMapping(value=\"/quick7\") @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String save7() throws IOException &#123; return \"hello itheima\"; &#125; @RequestMapping(value=\"/quick6\") public void save6(HttpServletResponse response) throws IOException &#123; response.getWriter().print(\"hello itcast\"); &#125; 07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)12345@RequestMapping(value=\"/quick8\") @ResponseBody public String save8() throws IOException &#123; return \"&#123;\\\"username\\\":\\\"zhangsan\\\",\\\"age\\\":18&#125;\"; &#125; 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 123456789101112@RequestMapping(value=\"/quick9\") @ResponseBody public String save9() throws IOException &#123; User user = new User(); user.setUsername(\"lisi\"); user.setAge(30); //使用json的转换工具将对象转换成json格式字符串在返回 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json; &#125; 08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 1234567&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 123456789@RequestMapping(value=\"/quick10\") @ResponseBody //期望SpringMVC自动将User转换成json格式的字符串 public User save10() throws IOException &#123; User user = new User(); user.setUsername(\"lisi2\"); user.setAge(32); return user; &#125; 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置 1&lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求11-SpringMVC的请求-获得请求参数-请求参数类型(理解)客户端请求参数的格式是：name=value&amp;name=value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 123456@RequestMapping(value=\"/quick11\") @ResponseBody public void save11(String username,int age) throws IOException &#123; System.out.println(username); System.out.println(age); &#125; 13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 12345678910111213141516171819202122232425262728293031package com.itheima.domain;public class User &#123; private String username; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"username='\" + username + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 12345@RequestMapping(value=\"/quick12\") @ResponseBody public void save12(User user) throws IOException &#123; System.out.println(user); &#125; 14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 12345@RequestMapping(value=\"/quick13\") @ResponseBody public void save13(String[] strs) throws IOException &#123; System.out.println(Arrays.asList(strs)); &#125; 15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 12345678&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/user/quick14\" method=\"post\"&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=\"text\" name=\"userList[0].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[0].age\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].username\"&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"userList[1].age\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; 1234567891011121314151617181920212223package com.itheima.domain;import java.util.List;public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return \"VO&#123;\" + \"userList=\" + userList + '&#125;'; &#125;&#125; 12345@RequestMapping(value=\"/quick14\") @ResponseBody public void save14(VO vo) throws IOException &#123; System.out.println(vo); &#125; 16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 1234567891011121314&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js\"&gt;&lt;/script&gt; &lt;script&gt; var userList = new Array(); userList.push(&#123;username:\"zhangsan\",age:18&#125;); userList.push(&#123;username:\"lisi\",age:28&#125;); $.ajax(&#123; type:\"POST\", url:\"$&#123;pageContext.request.contextPath&#125;/user/quick15\", data:JSON.stringify(userList), contentType:\"application/json;charset=utf-8\" &#125;); &lt;/script&gt; 12345@RequestMapping(value=\"/quick15\") @ResponseBody public void save15(@RequestBody List&lt;User&gt; userList) throws IOException &#123; System.out.println(userList); &#125; 17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是/,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： •在spring-mvc.xml配置文件中指定放行的资源 ​ &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; •使用&lt;mvc:default-servlet-handler/&gt;标签 12345&lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"/&gt; &lt;mvc:resources mapping=\"/img/**\" location=\"/img/\"/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 12345678910111213&lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 1234&lt;form action=\"$&#123;pageContext.request.contextPath&#125;/quick16\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping(value=\"/quick16\") @ResponseBody public void save16(@RequestParam(value=\"name\",required = false,defaultValue = \"itcast\") String username) throws IOException &#123; System.out.println(username); &#125; 20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： /user/1 GET ： 得到 id = 1 的 user /user/1 DELETE： 删除 id = 1 的 user /user/1 PUT： 更新 id = 1 的 user /user POST： 新增 user 上述url地址/user/1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址/user/1可以写成/user/{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick17/zhangsan 12345@RequestMapping(value=\"/quick17/&#123;name&#125;\")@ResponseBody public void save17(@PathVariable(value=\"name\") String username) throws IOException &#123; System.out.println(username); &#125; 21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String dateStr) &#123; //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 12345@RequestMapping(value=\"/quick18\") @ResponseBody public void save18(Date date) throws IOException &#123; System.out.println(date); &#125; 22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(value=\"/quick19\") @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123; System.out.println(request); System.out.println(response); System.out.println(session); &#125; 23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(value=\"/quick20\") @ResponseBody public void save20(@RequestHeader(value = \"User-Agent\",required = false) String user_agent) throws IOException &#123; System.out.println(user_agent); &#125; 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(value=\"/quick21\") @ResponseBody public void save21(@CookieValue(value = \"JSESSIONID\") String jsessionId) throws IOException &#123; System.out.println(jsessionId); &#125;","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"SpringMVC 技术总结1：入门","slug":"2018-04-01-SpringMVC-技术总结1：入门","date":"2018-03-31T16:02:12.000Z","updated":"2020-03-06T09:18:26.980Z","comments":true,"path":"2018/04/01/2018-04-01-SpringMVC-技术总结1：入门/","link":"","permalink":"http://yoursite.com/2018/04/01/2018-04-01-SpringMVC-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931%EF%BC%9A%E5%85%A5%E9%97%A8/","excerpt":"","text":"1. Spring与Web环境集成1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 1.5 通过工具获得应用上下文对象123ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext); Object obj = applicationContext.getBean(\"id\"); 知识要点 Spring集成web环境步骤 ​ ①配置ContextLoaderListener监听器 ​ ②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC的简介2.1 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 2.3 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ③创建Controller和业务方法 123456public class QuickController &#123; public String quickMethod()&#123; System.out.println(\"quickMethod running.....\"); return \"index\"; &#125;&#125; ③创建视图页面index.jsp 12345&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ④配置注解 12345678@Controllerpublic class QuickController &#123; @RequestMapping(\"/quick\") public String quickMethod()&#123; System.out.println(\"quickMethod running.....\"); return \"index\"; &#125;&#125; ⑤创建spring-mvc.xml 12345678910111213&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=\"com.itheima\"/&gt;&lt;/beans&gt; ⑥访问测试地址 1http://localhost:8080/itheima_springmvc1/quick 控制台打印 页面显示 2.3 SpringMVC流程图示 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 3. SpringMVC的组件解析3.1 SpringMVC的执行流程 ①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params = {“accountName”}，表示请求参数必须有accountName ​ params = {“moeny!100”}，表示请求参数中money不能是100 1.mvc命名空间引入 123456命名空间：xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 2.组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package=“com.itheima.controller”/&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org/springframework/web/servlet/DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： 1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = \"redirect:\" --重定向前缀FORWARD_URL_PREFIX = \"forward:\" --转发前缀（默认值）prefix = \"\"; --视图名称前缀suffix = \"\"; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀 12345&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX = “redirect:” FORWARD_URL_PREFIX = “forward:” prefix = “”; suffix = “”;","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Spring 技术总结5：事务控制","slug":"2018-03-27-Spring-技术总结5：事务控制","date":"2018-03-26T16:13:15.000Z","updated":"2020-03-06T09:45:38.466Z","comments":true,"path":"2018/03/27/2018-03-27-Spring-技术总结5：事务控制/","link":"","permalink":"http://yoursite.com/2018/03/27/2018-03-27-Spring-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%935%EF%BC%9A%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/","excerpt":"","text":"一、编程式事务控制相关对象（了解）1. PlatformTransactionManager —&gt; 平台事务管理器 PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatus getTransaction(TransactionDefination defination) 获取事务的状态信息 void commit(TransactionStatus status) 提交事务 void rollback(TransactionStatus status) 回滚事务 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类， 例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 2. TransactionDefinition —&gt; 事务的定义对象，内部封装了控制事务的一些参数 TransactionDefinition 是事务的定义信息对象（维护事务的参数信息），里面有如下方法： 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly() 是否只读 2.1.事务隔离级别 ​ 设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED — 读未提交 ISOLATION_READ_COMMITTED — 读已提交的 ISOLATION_REPEATABLE_READ — 可重复读 ISOLATION_SERIALIZABLE — 串行化 2.2.事务传播行为 ​ 解决在调用业务方法时他们之间事务统一性问题 REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 3.TransactionStatus —&gt; 事务的状态对象 TransactionStatus 接口提供的是事务具体的运行状态（维护在不同的时间点事务的状态信息），方法介绍如下 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction() 是否是新事务 boolean isRollbackOnly() 事务是否回滚 二、基于XML的声明式事务控制1.什么是声明式事务控制 Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 2.声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 ​ 声明式事务控制运用的其实就是**AOP思想**，业务方法为切点，通知/增强为事务增强 注意：Spring 声明式事务控制底层就是AOP。 3.**声**明式事务控制的实现 声明式事务控制明确事项： 谁是切点？业务方法 谁是通知？事务(控制)增强 配置切面？ 引入tx命名空间 1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"​ xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"​ xmlns:aop=\"http://www.springframework.org/schema/aop\"​ **xmlns:tx=\"http://www.springframework.org/schema/tx\"**​ xsi:schemaLocation=\"​ http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd​ http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd​ **http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd**\"&gt; 配置事务增强 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--目标对象 内部的方法就是切点--&gt;&lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt;&lt;/bean&gt;&lt;!--配置平台事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--通知 事务的增强--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--设置事务的属性信息的--&gt; &lt;tx:attributes&gt;​ ****​ &lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\"/&gt;​ &lt;tx:method name=\"save\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"false\"/&gt;​ &lt;tx:method name=\"findAll\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\"/&gt;​ &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" read-only=\"true\"/&gt;​ &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice 配置事务 AOP 织入 123456789&lt;!--配置事务的aop织入--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"txPointcut\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointcut\"/&gt;&lt;/aop:config&gt; 测试事务控制转账业务代码 12345678910111213141516171819202122232425public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123;​ this.accountDao = accountDao; &#125; @Overwrite public void transfer(String outMan, String inMan, double money) &#123;​ accountDao.out(outMan,money);​ int i = 1/0;​ accountDao.in(inMan,money); &#125;&#125; 4.切点方法的事务参数的配置 12345678910111213&lt;!--通知 事务的增强--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--设置事务的属性信息的--&gt; &lt;tx:attributes&gt;​ &lt;tx:method name=\"*\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，tx:method 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name=\"transfer\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\" timeout=\"-1\" read-only=\"false\"/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 * 知识要点 声明式事务控制的配置要点： 平台事务管理器配置 — 目的：告诉Spring我要使用哪套API(技术)进行事务的控制 事务通知的配置 事务aop织入的配置 三、基于注解的声明式事务控制使用注解配置声明式事务控制 编写 AccoutDao 123456789101112131415161718192021@Repository(\"accountDao\")public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123;​ jdbcTemplate.update(\"update account set money=money-? where name=?\",money,outMan); &#125; public void in(String inMan, double money) &#123;​ jdbcTemplate.update(\"update account set money=money+? where name=?\",money,inMan); &#125;&#125; 编写 AccoutService 123456789101112131415161718192021222324252627@Service(\"accountService\")@Transactional(isolation = Isolation.REPEATABLE_READ)public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) &#123;​ accountDao.out(outMan,money);​ int i = 1/0;​ accountDao.in(inMan,money); &#125; //@Transactional(isolation = Isolation.DEFAULT) public void xxx()&#123;&#125;&#125; 编写 applicationContext.xml 配置文件 123456789&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima\"/&gt;&lt;!--事物的注解驱动--&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 注解配置声明式事务控制解析 使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 使用在方法上，不同的方法可以采用不同的事务参数配置。 Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven /&gt; * 知识要点 注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven/","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 技术总结4:JdbcTemplate","slug":"2018-03-26-Spring-技术总结4JdbcTemplate","date":"2018-03-25T17:45:22.000Z","updated":"2020-03-06T09:36:26.947Z","comments":true,"path":"2018/03/26/2018-03-26-Spring-技术总结4JdbcTemplate/","link":"","permalink":"http://yoursite.com/2018/03/26/2018-03-26-Spring-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%934JdbcTemplate/","excerpt":"","text":"1.JdbcTemplate概述 它是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。 例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 2.JDBCTemplate开发步骤 导入spring-jdbc和spring-tx坐标 创建数据库表和实体 创建JdbcTemplate对象 执行数据库操作 123456789101112131415161718192021222324252627282930313233@Test//测试JdbcTemplate开发步骤public void test1() throws PropertyVetoException &#123; //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"tom\", 5000); System.out.println(row);&#125; 3.Spring产生JdbcTemplate对象 我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring， 在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中，配置如下： 12345678910111213141516171819202122232425&lt;!--加载jdbc.properties--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--数据源对象--&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;&lt;!--jdbc模板对象--&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 从容器中获得JdbcTemplate进行添加操作 123456789101112131415@Test//测试Spring产生jdbcTemplate对象public void test2() throws PropertyVetoException &#123; ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(\"insert into account values(?,?)\", \"lisi\", 5000); System.out.println(row);&#125; 4.JdbcTemplate的常用操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class JdbcTemplateCRUDTest &#123; @Autowired private JdbcTemplate jdbcTemplate; @Test public void testQueryCount()&#123;​ Long count = jdbcTemplate.queryForObject(\"select count(*) from account\", Long.class);​ System.out.println(count); &#125; @Test public void testQueryOne()&#123;​ Account account = jdbcTemplate.queryForObject(\"select * from account where name=?\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class), \"tom\");​ System.out.println(account); &#125; @Test public void testQueryAll()&#123;​ List&lt;Account&gt; accountList = jdbcTemplate.query(\"select * from account\", new BeanPropertyRowMapper&lt;Account&gt;(Account.class));​ System.out.println(accountList); &#125; @Test public void testUpdate()&#123;​ jdbcTemplate.update(\"update account set money=? where name=?\",10000,\"tom\"); &#125; @Test public void testDelete()&#123;​ jdbcTemplate.update(\"delete from account where name=?\",\"tom\"); &#125;&#125; 知识小结： 导入spring-jdbc和spring-tx坐标 创建数据库表和实体 创建JdbcTemplate对象 JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); 执行数据库操作： 更新操作： jdbcTemplate.update (sql,params) 查询操作： jdbcTemplate.query (sql,Mapper,params) jdbcTemplate.queryForObject(sql,Mapper,params)","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 技术总结3：AOP","slug":"2018-03-25-Spring-技术总结3：AOP","date":"2018-03-25T12:21:44.000Z","updated":"2020-03-06T09:30:08.906Z","comments":true,"path":"2018/03/25/2018-03-25-Spring-技术总结3：AOP/","link":"","permalink":"http://yoursite.com/2018/03/25/2018-03-25-Spring-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%933%EF%BC%9AAOP/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 123public interface TargetInterface &#123; public void method();&#125; ②目标类 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; ③动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"前置增强代码...\"); Object invoke = method.invoke(target, args); System.out.println(\"后置增强代码...\"); return invoke; &#125; &#125;); ④ 调用代理对象的方法测试 12// 测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.6 cglib 的动态代理①目标类 12345public class Target &#123; public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; ②动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer(); //创建增强器enhancer.setSuperclass(Target.class); //设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"前置代码增强....\"); Object invoke = method.invoke(target, objects); System.out.println(\"后置代码增强....\"); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create(); //创建代理对象 ③调用代理对象的方法测试 12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义 Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项 1.8 AOP 开发明确的事项1)需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： Pointcut（切入点）：被增强的方法 Advice（通知/ 增强）：封装增强业务逻辑的方法 Aspect（切面）：切点+通知 Weaving（织入）：将切点与通知结合的过程 开发明确事项： 谁是切点（切点表达式配置） 谁是通知（切面类中的增强方法） 将切点和通知进行织入配置 2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 ①导入 AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; ③创建切面类（内部有增强方法） 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ④将目标类和切面类的对象创建权交给 spring 1234&lt;!--配置目标类--&gt;&lt;bean id=\"target\" class=\"com.itheima.aop.Target\"&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=\"myAspect\" class=\"com.itheima.aop.MyAspect\"&gt;&lt;/bean&gt; ⑤在 applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; ⑤在 applicationContext.xml 中配置织入关系 配置切点表达式和前置增强的织入关系 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=\"before\" pointcut=\"execution(public void com.itheima.aop.Target.method())\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如： 12345execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 2) 通知的类型通知的配置语法： 1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式\"&gt;&lt;/aop:通知类型&gt; 3) 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.itheima.aop.*.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2.3 知识要点 aop织入的配置 12345&lt;aop:config&gt; &lt;aop:aspect ref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; ②创建切面类（内部有增强方法) 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ③将目标类和切面类的对象创建权交给 spring 12345678910111213@Component(\"target\")public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125;@Component(\"myAspect\")public class MyAspect &#123; public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(\"myAspect\")@Aspectpublic class MyAspect &#123; @Before(\"execution(* com.itheima.aop.*.*(..))\") public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; ⑤在配置文件中开启组件扫描和 AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima.aop\"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; ⑦测试结果 3.2 注解配置 AOP 详解1) 注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 2) 切点表达式的抽取同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 12345678910@@Component(\"myAspect\")@Aspectpublic class MyAspect &#123; @Before(\"MyAspect.myPoint()\") public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125; @Pointcut(\"execution(* com.itheima.aop.*.*(..))\") public void myPoint()&#123;&#125;&#125; 3.3 知识要点 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 通知注解类型 ​","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 技术总结2","slug":"2018-03-24-Spring-技术总结2","date":"2018-03-24T13:07:22.000Z","updated":"2020-03-06T09:28:39.947Z","comments":true,"path":"2018/03/24/2018-03-24-Spring-技术总结2/","link":"","permalink":"http://yoursite.com/2018/03/24/2018-03-24-Spring-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%932/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 开发步骤 ①导入数据源的坐标和数据库驱动坐标 ②创建数据源对象 ③设置数据源的基本连接数据 ④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 123456789101112&lt;!-- C3P0连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; ①导入mysql数据库驱动坐标 123456&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; ②创建C3P0连接池 123456789101112@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ②创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ③提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root ④读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle(\"jdbc\"); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(\"jdbc.driver\")); dataSource.setJdbcUrl(rb.getString(\"jdbc.url\")); dataSource.setUser(rb.getString(\"jdbc.username\")); dataSource.setPassword(rb.getString(\"jdbc.password\")); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 123456ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); DataSource dataSource = (DataSource) applicationContext.getBean(\"dataSource\");Connection connection = dataSource.getConnection();System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context=”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 12&lt;context:property-placeholder location=\"xx.properties\"/&gt;&lt;property name=\"\" value=\"$&#123;key&#125;\"/&gt; 2. Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345678//@Component(\"userDao\")@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"save running... ...\"); &#125;&#125; 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112//@Component(\"userService\")@Service(\"userService\")public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier(\"userDao\")*/ @Resource(name=\"userDao\") private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 使用@Value进行字符串的注入 12345678910111213@Repository(\"userDao\")public class UserDaoImpl implements UserDao &#123; @Value(\"注入普通数据\") private String str; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Override public void save() &#123; System.out.println(str); System.out.println(driver); System.out.println(\"save running... ...\"); &#125;&#125; 使用@Scope标注Bean的范围 12345//@Scope(\"prototype\")@Scope(\"singleton\")public class UserDaoImpl implements UserDao &#123; //此处省略代码&#125; 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstructpublic void init()&#123; System.out.println(\"初始化方法....\");&#125;@PreDestroypublic void destroy()&#123; System.out.println(\"销毁方法.....\");&#125; 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置： 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan 引入其他文件： 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import 12345@Configuration@ComponentScan(\"com.itheima\")@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125; @PropertySource @value 12345678910@PropertySource(\"classpath:jdbc.properties\")public class DataSourceConfiguration &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean 123456789@Bean(name=\"dataSource\")public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 测试加载核心配置类创建Spring容器 1234567891011@Testpublic void testAnnoConfiguration() throws Exception &#123;ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(\"userService\"); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(\"dataSource\"); Connection connection = dataSource.getConnection(); System.out.println(connection); &#125; 3. Spring整合Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\");IAccountService as = ac.getBean(\"accountService\",IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 123@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125; ③使用@ContextConfiguration指定配置文件或配置类 1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;\"classpath:applicationContext.xml\"&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; ④使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; ⑤创建测试方法进行测试 123456789@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; Spring集成Junit步骤 ①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring 技术总结1：概述","slug":"2018-03-21-Spring-技术总结1：概述","date":"2018-03-20T16:03:12.000Z","updated":"2020-03-06T09:27:23.250Z","comments":true,"path":"2018/03/21/2018-03-21-Spring-技术总结1：概述/","link":"","permalink":"http://yoursite.com/2018/03/21/2018-03-21-Spring-%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%931%EF%BC%9A%E6%A6%82%E8%BF%B0/","excerpt":"","text":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 1.2 Spring发展历程 （了解）Rod Johnson （ Spring 之父） 2017 年9 月份发布了 Spring 的最新版本 Spring5.0通用版（GA） 1.3 Spring的优势（理解）方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 1.4 Spring的体系结构（了解） 2. spring快速入门2.1 Spring程序开发步骤①导入 Spring 开发的基本包坐标 ②编写 Dao 接口和实现类 ③创建 Spring 核心配置文件 ④在 Spring 配置文件中配置 UserDaoImpl ⑤使用 Spring 的 API 获得 Bean 实例 2.2 导入Spring开发的基本包坐标1234567891011&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 编写Dao接口和实现类12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(\"UserDao save method running....\"); &#125;&#125; 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 2.6 使用Spring的API获得Bean实例123456@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\"); userDao.save(); &#125; 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 3.3 Bean生命周期配置init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式1） 使用无参构造方法实例化 ​ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 1&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt; 2） 工厂静态方法实例化 ​ 工厂的静态方法返回Bean实例 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=\"userDao\" class=\"com.itheima.factory.StaticFactoryBean\" factory-method=\"createUserDao\" /&gt; 3） 工厂实例方法实例化 ​ 工厂的非静态方法返回Bean实例 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=\"factoryBean\" class=\"com.itheima.factory.DynamicFactoryBean\"/&gt;&lt;bean id=\"userDao\" factory-bean=\"factoryBean\" factory-method=\"createUserDao\"/&gt; 3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\"); userDao.save(); &#125; &#125; ②将 UserServiceImpl 的创建权交给 Spring 1&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"/&gt; ③从 Spring 容器中获得 UserService 进行操作 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");UserService userService = (UserService) applicationContext.getBean(\"userService\");userService.save(); 3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.7 Bean的依赖注入方式①构造方法 ​ 创建有参构造 12345678public class UserServiceImpl implements UserService &#123;@Overridepublic void save() &#123;ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserDao userDao = (UserDao) applicationContext.getBean(\"userDao\"); userDao.save(); &#125; &#125; ​ 配置Spring容器调用有参构造时进行注入 123&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; ②set方法 ​ 在UserServiceImpl中添加setUserDao方法 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; ​ 配置Spring容器调用set方法进行注入 1234&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt; set方法:P命名空间注入 ​ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： ​ 首先，需要引入P命名空间： 1xmlns:p=\"http://www.springframework.org/schema/p\" 其次，需要修改注入方式 12&lt;bean id=\"userService\" class=\"com.itheima.service.impl.UserServiceImpl\" p:userDao- ref=\"userDao\"/&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，处了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 Bean的依赖注入的数据类型 （1）普通数据类型的注入 1234567891011121314public class UserDaoImpl implements UserDao &#123;private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+\"===\"+age); System.out.println(\"UserDao save method running....\"); &#125;&#125; 1234&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"company\" value=\"传智播客\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt;&lt;/bean&gt; （2）集合数据类型（List）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; public void save() &#123; System.out.println(strList); System.out.println(\"UserDao save method running....\"); &#125;&#125; 123456789&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"strList\"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; （3）集合数据类型（List）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125;public void save() &#123; System.out.println(userList); System.out.println(\"UserDao save method running....\"); &#125;&#125; 123456789101112&lt;bean id=\"u1\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"u2\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"userList\"&gt; &lt;list&gt; &lt;bean class=\"com.itheima.domain.User\"/&gt; &lt;bean class=\"com.itheima.domain.User\"/&gt; &lt;ref bean=\"u1\"/&gt; &lt;ref bean=\"u2\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; （4）集合数据类型（ Map&lt;String,User&gt; ）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public void save() &#123; System.out.println(userMap); System.out.println(\"UserDao save method running....\"); &#125;&#125; 12345678910&lt;bean id=\"u1\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"u2\" class=\"com.itheima.domain.User\"/&gt;&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"userMap\"&gt; &lt;map&gt; &lt;entry key=\"user1\" value-ref=\"u1\"/&gt; &lt;entry key=\"user2\" value-ref=\"u2\"/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; （5）集合数据类型（Properties）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println(\"UserDao save method running....\"); &#125;&#125; 123456789&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"p1\"&gt;aaa&lt;/prop&gt; &lt;prop key=\"p2\"&gt;bbb&lt;/prop&gt; &lt;prop key=\"p3\"&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 1&lt;import resource=\"applicationContext-xxx.xml\"/&gt; 4. spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext ​ 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext ​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext ​ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 4.3 getBean()方法使用1234567public Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125;public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125; 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法使用 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserService userService1 = (UserService) applicationContext.getBean(\"userService\"); UserService userService2 = applicationContext.getBean(UserService.class);","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Template","slug":"First-Blog的副本","date":"2018-03-20T16:02:12.000Z","updated":"2020-03-05T11:25:28.586Z","comments":true,"path":"2018/03/21/First-Blog的副本/","link":"","permalink":"http://yoursite.com/2018/03/21/First-Blog%E7%9A%84%E5%89%AF%E6%9C%AC/","excerpt":"","text":"","categories":[],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]}]}